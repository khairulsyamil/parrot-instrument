/*
Copyright (C) 2010, Parrot Foundation.
$Id: instrumentgc.pmc 48438 2010-08-12 19:43:40Z khairul $

=head1 NAME

src/dynpmc/instrumentgc.pmc - Interface to instrument the gc_sys entry of Parrot_Interp.

=head1 DESCRIPTION

C<InstrumentPMC> is a PMC class that provides an interface to
instrument the gc_sys entry of Parrot_Interp.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

#include "pmc_instrument.h"
#include "gc_private.h"

#include "instrument_private.h"
#include "instrument_extern.h"

/* BELOW LIES GENERATED CODE GENERATED BY tools/build/gen_gc_stubs.pl */
typedef struct InstrumentGC_Subsystem {
    /* Common entries taken from GC_Subsystem. */
    /* BEGIN gc struct entries */
gc_sys_type_enum sys_type;
void (*finalize_gc_system) (PARROT_INTERP);
void (*destroy_child_interp)(Interp *dest_interp, Interp *child_interp);
void (*do_gc_mark)(PARROT_INTERP, UINTVAL flags);
void (*compact_string_pool)(PARROT_INTERP);
void (*mark_special)(PARROT_INTERP, PMC *);
void (*pmc_needs_early_collection)(PARROT_INTERP, PMC *);
void (*init_pool)(PARROT_INTERP, struct Fixed_Size_Pool *);
PMC* (*allocate_pmc_header)(PARROT_INTERP, UINTVAL flags);
void (*free_pmc_header)(PARROT_INTERP, PMC *);
STRING* (*allocate_string_header)(PARROT_INTERP, UINTVAL flags);
void (*free_string_header)(PARROT_INTERP, STRING*);
Buffer* (*allocate_bufferlike_header)(PARROT_INTERP, size_t size);
void (*free_bufferlike_header)(PARROT_INTERP, Buffer*, size_t size);
void* (*allocate_pmc_attributes)(PARROT_INTERP, PMC *);
void (*free_pmc_attributes)(PARROT_INTERP, PMC *);
void (*allocate_string_storage)(PARROT_INTERP, STRING *str, size_t size);
void (*reallocate_string_storage)(PARROT_INTERP, STRING *str, size_t size);
void (*allocate_buffer_storage)(PARROT_INTERP, ARGMOD(Buffer *buffer), size_t nsize);
void (*reallocate_buffer_storage)(PARROT_INTERP, ARGMOD(Buffer *buffer), size_t newsize);
void* (*allocate_fixed_size_storage)(PARROT_INTERP, size_t size);
void (*free_fixed_size_storage)(PARROT_INTERP, size_t size, void *);
void* (*allocate_memory_chunk)(PARROT_INTERP, size_t size);
void* (*reallocate_memory_chunk)(PARROT_INTERP, void *data, size_t newsize);
void* (*allocate_memory_chunk_with_interior_pointers)(PARROT_INTERP, size_t size);
void* (*reallocate_memory_chunk_with_interior_pointers)(PARROT_INTERP, void *data,
                                                        size_t oldsize, size_t newsize);
void (*free_memory_chunk)(PARROT_INTERP, void *data);
void (*block_mark)(PARROT_INTERP);
void (*unblock_mark)(PARROT_INTERP);
unsigned int (*is_blocked_mark)(PARROT_INTERP);
void (*block_sweep)(PARROT_INTERP);
void (*unblock_sweep)(PARROT_INTERP);
unsigned int (*is_blocked_sweep)(PARROT_INTERP);
size_t (*get_gc_info)(PARROT_INTERP, Interpinfo_enum);
    /* END gc struct entries */
    /* End of common entries. */

    /* Additional Entries. */
    PMC           *instrument_gc;
    Parrot_Interp  supervisor;
    GC_Subsystem  *original;
} InstrumentGC_Subsystem;
/* END OF GENERATED CODE */

/* Macros for generated stubs */
#define GC_STUB_VARS \
    GC_Subsystem  *gc_orig      = ((InstrumentGC_Subsystem *) interp->gc_sys)->original; \
    Parrot_Interp  supervisor   = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor; \
    PMC           *instrumentgc = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc; \
    PMC *instrument, *recall, *event_data, *temp, *params, *event_array; \
    STRING *raise_event, *event; \
    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);

#define GC_STUB_CALL_PRE \
    VTABLE_set_pmc_keyed_str(supervisor, event_data, \
                             CONST_STRING(supervisor, "parameters"), params); \
    raise_event = CONST_STRING(supervisor, "raise_event"); \
    GETATTR_InstrumentGC_instrument(supervisor, instrumentgc, instrument); \
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, \
                                         "SP->P", event, event_data, &recall);

#define GC_STUB_CALL_POST \
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, \
                                         "SPP->P", event, event_data, recall, &recall); \
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));

/* Prototypes for helper functions. */
void setup_gc_common_hashes(PARROT_INTERP);
void destroy_gc_common_hashes(PARROT_INTERP);
void setup_gc_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                GC_Subsystem *gc_orig, InstrumentGC_Subsystem *gc_instr);

/* Globals used internally. */
static INTVAL  gc_first_run   = 1;
static Hash   *gc_registry    = NULL;
static Hash   *gc_name_stubs  = NULL;
static Hash   *gc_group_items = NULL;
static Hash   *gc_item_groups = NULL;

pmclass InstrumentGC auto_attrs dynpmc group instrument_group extends InstrumentStubBase {

/*
=item C<void init_pmc(PMC *instrument)>

Initialises and prepares the supervised interpreter for GC instrumenting.

=cut

*/

    VTABLE void init_pmc(PMC *instrument) {
        Parrot_InstrumentGC_attributes * const attr = PARROT_INSTRUMENTGC(SELF);
        Parrot_Interp supervised;
        InstrumentGC_Subsystem *sub;
        SUPER(instrument);

        GETATTR_Instrument_supervised(INTERP, instrument, supervised);

        /* Initialise the structs */
        sub = mem_gc_allocate_zeroed_typed(INTERP, InstrumentGC_Subsystem);
        attr->original_struct     = supervised->gc_sys;
        attr->instrumented_struct = sub;

        /* Initiliase the instrumented gc_sys with the original values. */
        sub->instrument_gc = SELF;
        sub->supervisor    = INTERP;
        sub->original      = (GC_Subsystem *) attr->original_struct;

        /* Set the gc_sys of the supervised to the instrumented gc_sys. */
        mem_copy_n_typed(attr->instrumented_struct, attr->original_struct, 1, GC_Subsystem);
        supervised->gc_sys = (GC_Subsystem *) attr->instrumented_struct;

        /* Initialise the hashes. */
        setup_gc_common_hashes(INTERP);
        setup_gc_individual_hashes(INTERP, attr->name_original, attr->name_offset,
                                   (GC_Subsystem *) attr->original_struct,
                                   (InstrumentGC_Subsystem *) attr->instrumented_struct);

        /* Update the attributes to point to the static hashes. */
        attr->name_stubs  = gc_name_stubs;
        attr->group_items = gc_group_items;
        attr->item_groups = gc_item_groups;

        /* Register self in the registry. */
        parrot_hash_put(INTERP, gc_registry, SELF, SELF);
    }

/*

=item C<void destroy()>

Performs cleanup for InstrumentGC attributes.

=cut

*/

    VTABLE void destroy() {
        Parrot_InstrumentGC_attributes * const attr = PARROT_INSTRUMENTGC(SELF);
        SUPER();
        parrot_hash_delete(INTERP, gc_registry, SELF);
        destroy_gc_common_hashes(INTERP);
    }
}

/* BELOW LIES GENERATED CODE GENERATED BY tools/build/gen_gc_stubs.pl */
/* BEGIN gc prototypes */
void  stub_finalize_gc_system(PARROT_INTERP);
void  stub_destroy_child_interp(Interp* dest_interp, Interp* child_interp);
void  stub_do_gc_mark(PARROT_INTERP, UINTVAL flags);
void  stub_compact_string_pool(PARROT_INTERP);
void  stub_mark_special(PARROT_INTERP, PMC*  stub_var1);
void  stub_pmc_needs_early_collection(PARROT_INTERP, PMC*  stub_var1);
void  stub_init_pool(PARROT_INTERP, struct Fixed_Size_Pool*  stub_var1);
PMC*  stub_allocate_pmc_header(PARROT_INTERP, UINTVAL flags);
void  stub_free_pmc_header(PARROT_INTERP, PMC*  stub_var1);
STRING*  stub_allocate_string_header(PARROT_INTERP, UINTVAL flags);
void  stub_free_string_header(PARROT_INTERP, STRING* stub_var1);
Buffer*  stub_allocate_bufferlike_header(PARROT_INTERP, size_t size);
void  stub_free_bufferlike_header(PARROT_INTERP, Buffer* stub_var1, size_t size);
void*  stub_allocate_pmc_attributes(PARROT_INTERP, PMC*  stub_var1);
void  stub_free_pmc_attributes(PARROT_INTERP, PMC*  stub_var1);
void  stub_allocate_string_storage(PARROT_INTERP, STRING* str, size_t size);
void  stub_reallocate_string_storage(PARROT_INTERP, STRING* str, size_t size);
void  stub_allocate_buffer_storage(PARROT_INTERP, Buffer* buffer, size_t nsize);
void  stub_reallocate_buffer_storage(PARROT_INTERP, Buffer* buffer, size_t newsize);
void*  stub_allocate_fixed_size_storage(PARROT_INTERP, size_t size);
void  stub_free_fixed_size_storage(PARROT_INTERP, size_t size, void*  stub_var1);
void*  stub_allocate_memory_chunk(PARROT_INTERP, size_t size);
void*  stub_reallocate_memory_chunk(PARROT_INTERP, void* data, size_t newsize);
void*  stub_allocate_memory_chunk_with_interior_pointers(PARROT_INTERP, size_t size);
void*  stub_reallocate_memory_chunk_with_interior_pointers(PARROT_INTERP, void* data,
                                                           size_t oldsize, size_t newsize);
void  stub_free_memory_chunk(PARROT_INTERP, void* data);
void  stub_block_mark(PARROT_INTERP);
void  stub_unblock_mark(PARROT_INTERP);
void  stub_block_sweep(PARROT_INTERP);
void  stub_unblock_sweep(PARROT_INTERP);
/* END gc prototypes */

void setup_gc_common_hashes(PARROT_INTERP) {
    PMC *temp;
    if (!gc_first_run) return;

    gc_first_run   = 0;
    gc_registry    = parrot_new_pointer_hash(interp);
    gc_name_stubs  = parrot_new_hash(interp);
    gc_group_items = parrot_new_hash(interp);
    gc_item_groups = parrot_new_hash(interp);

    /* BEGIN gc mapping name stubs */
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "finalize_gc_system"),
        stub_finalize_gc_system);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "destroy_child_interp"),
        stub_destroy_child_interp);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "do_gc_mark"),
        stub_do_gc_mark);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "compact_string_pool"),
        stub_compact_string_pool);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "mark_special"),
        stub_mark_special);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        stub_pmc_needs_early_collection);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "init_pool"),
        stub_init_pool);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_pmc_header"),
        stub_allocate_pmc_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_pmc_header"),
        stub_free_pmc_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_string_header"),
        stub_allocate_string_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_string_header"),
        stub_free_string_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        stub_allocate_bufferlike_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_bufferlike_header"),
        stub_free_bufferlike_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        stub_allocate_pmc_attributes);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_pmc_attributes"),
        stub_free_pmc_attributes);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_string_storage"),
        stub_allocate_string_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "reallocate_string_storage"),
        stub_reallocate_string_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_buffer_storage"),
        stub_allocate_buffer_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        stub_reallocate_buffer_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        stub_allocate_fixed_size_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_fixed_size_storage"),
        stub_free_fixed_size_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_memory_chunk"),
        stub_allocate_memory_chunk);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        stub_reallocate_memory_chunk);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        stub_allocate_memory_chunk_with_interior_pointers);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        stub_reallocate_memory_chunk_with_interior_pointers);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_memory_chunk"),
        stub_free_memory_chunk);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "block_mark"),
        stub_block_mark);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "unblock_mark"),
        stub_unblock_mark);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "block_sweep"),
        stub_block_sweep);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "unblock_sweep"),
        stub_unblock_sweep);
    /* END gc mapping name stubs */

    /* BEGIN gc mapping group items */
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_pmc_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_string_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_bufferlike_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_pmc_attributes"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_fixed_size_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_memory_chunk"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "free"),
                    temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "finalize_gc_system"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "destroy_child_interp"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "do_gc_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "compact_string_pool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "mark_special"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pmc_needs_early_collection"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init_pool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "block_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unblock_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "block_sweep"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unblock_sweep"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "administration"),
                    temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_pmc_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_string_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_bufferlike_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_pmc_attributes"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_string_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_buffer_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_fixed_size_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "allocate"),
                    temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "finalize_gc_system"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "destroy_child_interp"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "do_gc_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "compact_string_pool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "mark_special"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pmc_needs_early_collection"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init_pool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_pmc_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_pmc_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_string_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_string_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_bufferlike_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_bufferlike_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_pmc_attributes"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_pmc_attributes"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_string_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_string_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_buffer_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_buffer_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_fixed_size_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_fixed_size_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "block_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unblock_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "block_sweep"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unblock_sweep"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "all"),
                    temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_string_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_buffer_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "reallocate"),
                    temp);
    /* END gc mapping group items */

    /* BEGIN gc mapping item groups */
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "finalize_gc_system"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "destroy_child_interp"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "do_gc_mark"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "compact_string_pool"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "mark_special"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "init_pool"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_pmc_header"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_pmc_header"),
        CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_string_header"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_string_header"),
        CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_bufferlike_header"),
        CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_pmc_attributes"),
        CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_string_storage"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "reallocate_string_storage"),
        CONST_STRING(interp, "reallocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_buffer_storage"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        CONST_STRING(interp, "reallocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_fixed_size_storage"),
        CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_memory_chunk"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        CONST_STRING(interp, "reallocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        CONST_STRING(interp, "reallocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_memory_chunk"),
        CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "block_mark"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "unblock_mark"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "block_sweep"),
        CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "unblock_sweep"),
        CONST_STRING(interp, "administration"));
    /* END gc mapping item groups */
}

void destroy_gc_common_hashes(PARROT_INTERP) {
    if (gc_registry == NULL) { return; }

    if (parrot_hash_size(interp, gc_registry) == 0) {
        parrot_hash_destroy(interp, gc_registry);
        parrot_hash_destroy(interp, gc_name_stubs);
        parrot_hash_destroy(interp, gc_group_items);
        parrot_hash_destroy(interp, gc_item_groups);

        gc_first_run = 1;
        gc_registry    = NULL;
        gc_name_stubs  = NULL;
        gc_group_items = NULL;
        gc_item_groups = NULL;
    }
}

void setup_gc_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                GC_Subsystem *gc_orig, InstrumentGC_Subsystem *gc_instr) {
    /* BEGIN gc mapping name offset */
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "finalize_gc_system"),
        &(gc_instr->finalize_gc_system));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "destroy_child_interp"),
        &(gc_instr->destroy_child_interp));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "do_gc_mark"),
        &(gc_instr->do_gc_mark));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "compact_string_pool"),
        &(gc_instr->compact_string_pool));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "mark_special"),
        &(gc_instr->mark_special));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        &(gc_instr->pmc_needs_early_collection));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init_pool"),
        &(gc_instr->init_pool));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_pmc_header"),
        &(gc_instr->allocate_pmc_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_pmc_header"),
        &(gc_instr->free_pmc_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_string_header"),
        &(gc_instr->allocate_string_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_string_header"),
        &(gc_instr->free_string_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        &(gc_instr->allocate_bufferlike_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_bufferlike_header"),
        &(gc_instr->free_bufferlike_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        &(gc_instr->allocate_pmc_attributes));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_pmc_attributes"),
        &(gc_instr->free_pmc_attributes));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_string_storage"),
        &(gc_instr->allocate_string_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_string_storage"),
        &(gc_instr->reallocate_string_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_buffer_storage"),
        &(gc_instr->allocate_buffer_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        &(gc_instr->reallocate_buffer_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        &(gc_instr->allocate_fixed_size_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_fixed_size_storage"),
        &(gc_instr->free_fixed_size_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_memory_chunk"),
        &(gc_instr->allocate_memory_chunk));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        &(gc_instr->reallocate_memory_chunk));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        &(gc_instr->allocate_memory_chunk_with_interior_pointers));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        &(gc_instr->reallocate_memory_chunk_with_interior_pointers));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_memory_chunk"),
        &(gc_instr->free_memory_chunk));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "block_mark"),
        &(gc_instr->block_mark));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unblock_mark"),
        &(gc_instr->unblock_mark));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "block_sweep"),
        &(gc_instr->block_sweep));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unblock_sweep"),
        &(gc_instr->unblock_sweep));
    /* END gc mapping name offset */

    /* BEGIN gc mapping name original */
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "finalize_gc_system"),
        gc_orig->finalize_gc_system);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "destroy_child_interp"),
        gc_orig->destroy_child_interp);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "do_gc_mark"),
        gc_orig->do_gc_mark);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "compact_string_pool"),
        gc_orig->compact_string_pool);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "mark_special"),
        gc_orig->mark_special);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        gc_orig->pmc_needs_early_collection);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init_pool"),
        gc_orig->init_pool);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_pmc_header"),
        gc_orig->allocate_pmc_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_pmc_header"),
        gc_orig->free_pmc_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_string_header"),
        gc_orig->allocate_string_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_string_header"),
        gc_orig->free_string_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        gc_orig->allocate_bufferlike_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_bufferlike_header"),
        gc_orig->free_bufferlike_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        gc_orig->allocate_pmc_attributes);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_pmc_attributes"),
        gc_orig->free_pmc_attributes);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_string_storage"),
        gc_orig->allocate_string_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_string_storage"),
        gc_orig->reallocate_string_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_buffer_storage"),
        gc_orig->allocate_buffer_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        gc_orig->reallocate_buffer_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        gc_orig->allocate_fixed_size_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_fixed_size_storage"),
        gc_orig->free_fixed_size_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_memory_chunk"),
        gc_orig->allocate_memory_chunk);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        gc_orig->reallocate_memory_chunk);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        gc_orig->allocate_memory_chunk_with_interior_pointers);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        gc_orig->reallocate_memory_chunk_with_interior_pointers);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_memory_chunk"),
        gc_orig->free_memory_chunk);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "block_mark"),
        gc_orig->block_mark);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unblock_mark"),
        gc_orig->unblock_mark);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "block_sweep"),
        gc_orig->block_sweep);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unblock_sweep"),
        gc_orig->unblock_sweep);
    /* END gc mapping name original */
}

/* BEGIN gc stubs */
void  stub_finalize_gc_system(Parrot_Interp interp) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "V", interp);
    event  = CONST_STRING(supervisor, "GC::administration::finalize_gc_system");
    GC_STUB_CALL_PRE;
    (gc_orig->finalize_gc_system(interp));
    GC_STUB_CALL_POST;
}

void  stub_destroy_child_interp(Interp* interp, Interp* child_interp) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VV", interp, child_interp);
    event  = CONST_STRING(supervisor, "GC::administration::destroy_child_interp");
    GC_STUB_CALL_PRE;
    (gc_orig->destroy_child_interp(interp, child_interp));
    GC_STUB_CALL_POST;
}

void  stub_do_gc_mark(Parrot_Interp interp, UINTVAL flags) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VV", interp, flags);
    event  = CONST_STRING(supervisor, "GC::administration::do_gc_mark");
    GC_STUB_CALL_PRE;
    (gc_orig->do_gc_mark(interp, flags));
    GC_STUB_CALL_POST;
}

void  stub_compact_string_pool(Parrot_Interp interp) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "V", interp);
    event  = CONST_STRING(supervisor, "GC::administration::compact_string_pool");
    GC_STUB_CALL_PRE;
    (gc_orig->compact_string_pool(interp));
    GC_STUB_CALL_POST;
}

void  stub_mark_special(Parrot_Interp interp, PMC* stub_var1) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VP", interp, stub_var1);
    event  = CONST_STRING(supervisor, "GC::administration::mark_special");
    GC_STUB_CALL_PRE;
    (gc_orig->mark_special(interp, stub_var1));
    GC_STUB_CALL_POST;
}

void  stub_pmc_needs_early_collection(Parrot_Interp interp, PMC* stub_var1) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VP", interp, stub_var1);
    event  = CONST_STRING(supervisor, "GC::administration::pmc_needs_early_collection");
    GC_STUB_CALL_PRE;
    (gc_orig->pmc_needs_early_collection(interp, stub_var1));
    GC_STUB_CALL_POST;
}

void  stub_init_pool(Parrot_Interp interp, struct Fixed_Size_Pool* stub_var1) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VV", interp, stub_var1);
    event  = CONST_STRING(supervisor, "GC::administration::init_pool");
    GC_STUB_CALL_PRE;
    (gc_orig->init_pool(interp, stub_var1));
    GC_STUB_CALL_POST;
}

PMC*  stub_allocate_pmc_header(Parrot_Interp interp, UINTVAL flags) {
    PMC*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VV", interp, flags);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_pmc_header");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        sizeof (PMC));
    GC_STUB_CALL_PRE;
    ret = (gc_orig->allocate_pmc_header(interp, flags));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void  stub_free_pmc_header(Parrot_Interp interp, PMC* stub_var1) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VP", interp, stub_var1);
    event  = CONST_STRING(supervisor, "GC::free::free_pmc_header");
    GC_STUB_CALL_PRE;
    (gc_orig->free_pmc_header(interp, stub_var1));
    GC_STUB_CALL_POST;
}

STRING*  stub_allocate_string_header(Parrot_Interp interp, UINTVAL flags) {
    STRING*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VV", interp, flags);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_string_header");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        sizeof (STRING));
    GC_STUB_CALL_PRE;
    ret = (gc_orig->allocate_string_header(interp, flags));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void  stub_free_string_header(Parrot_Interp interp, STRING* stub_var1) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VS", interp, stub_var1);
    event  = CONST_STRING(supervisor, "GC::free::free_string_header");
    GC_STUB_CALL_PRE;
    (gc_orig->free_string_header(interp, stub_var1));
    GC_STUB_CALL_POST;
}

Buffer*  stub_allocate_bufferlike_header(Parrot_Interp interp, size_t size) {
    Buffer*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VI", interp, size);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_bufferlike_header");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        sizeof (Buffer));
    GC_STUB_CALL_PRE;
    ret = (gc_orig->allocate_bufferlike_header(interp, size));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void  stub_free_bufferlike_header(Parrot_Interp interp, Buffer* stub_var1, size_t size) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VVI", interp, stub_var1, size);
    event  = CONST_STRING(supervisor, "GC::free::free_bufferlike_header");
    GC_STUB_CALL_PRE;
    (gc_orig->free_bufferlike_header(interp, stub_var1, size));
    GC_STUB_CALL_POST;
}

void*  stub_allocate_pmc_attributes(Parrot_Interp interp, PMC* stub_var1) {
    void*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VP", interp, stub_var1);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_pmc_attributes");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        VTABLE_get_pmc_keyed_int(supervisor, params, 0)->vtable->attr_size);
    GC_STUB_CALL_PRE;
    ret = (gc_orig->allocate_pmc_attributes(interp, stub_var1));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void  stub_free_pmc_attributes(Parrot_Interp interp, PMC* stub_var1) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VP", interp, stub_var1);
    event  = CONST_STRING(supervisor, "GC::free::free_pmc_attributes");
    GC_STUB_CALL_PRE;
    (gc_orig->free_pmc_attributes(interp, stub_var1));
    GC_STUB_CALL_POST;
}

void  stub_allocate_string_storage(Parrot_Interp interp, STRING* str, size_t size) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VSI", interp, str, size);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_string_storage");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        size);
    GC_STUB_CALL_PRE;
    (gc_orig->allocate_string_storage(interp, str, size));
    GC_STUB_CALL_POST;
}

void  stub_reallocate_string_storage(Parrot_Interp interp, STRING* str, size_t size) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VSI", interp, str, size);
    event  = CONST_STRING(supervisor, "GC::reallocate::reallocate_string_storage");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        size);
    GC_STUB_CALL_PRE;
    (gc_orig->reallocate_string_storage(interp, str, size));
    GC_STUB_CALL_POST;
}

void  stub_allocate_buffer_storage(Parrot_Interp interp, Buffer* buffer, size_t nsize) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VVI", interp, buffer, nsize);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_buffer_storage");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        nsize);
    GC_STUB_CALL_PRE;
    (gc_orig->allocate_buffer_storage(interp, buffer, nsize));
    GC_STUB_CALL_POST;
}

void  stub_reallocate_buffer_storage(Parrot_Interp interp, Buffer* buffer, size_t newsize) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VVI", interp, buffer, newsize);
    event  = CONST_STRING(supervisor, "GC::reallocate::reallocate_buffer_storage");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        newsize);
    GC_STUB_CALL_PRE;
    (gc_orig->reallocate_buffer_storage(interp, buffer, newsize));
    GC_STUB_CALL_POST;
}

void*  stub_allocate_fixed_size_storage(Parrot_Interp interp, size_t size) {
    void*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VI", interp, size);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_fixed_size_storage");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        size);
    GC_STUB_CALL_PRE;
    ret = (gc_orig->allocate_fixed_size_storage(interp, size));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void  stub_free_fixed_size_storage(Parrot_Interp interp, size_t size, void* stub_var1) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VIV", interp, size, stub_var1);
    event  = CONST_STRING(supervisor, "GC::free::free_fixed_size_storage");
    GC_STUB_CALL_PRE;
    (gc_orig->free_fixed_size_storage(interp, size, stub_var1));
    GC_STUB_CALL_POST;
}

void*  stub_allocate_memory_chunk(Parrot_Interp interp, size_t size) {
    void*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VI", interp, size);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_memory_chunk");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        size);
    GC_STUB_CALL_PRE;
    ret = (gc_orig->allocate_memory_chunk(interp, size));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void*  stub_reallocate_memory_chunk(Parrot_Interp interp, void* data, size_t newsize) {
    void*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VVI", interp, data, newsize);
    event  = CONST_STRING(supervisor, "GC::reallocate::reallocate_memory_chunk");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        newsize);
    GC_STUB_CALL_PRE;
    ret = (gc_orig->reallocate_memory_chunk(interp, data, newsize));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void*  stub_allocate_memory_chunk_with_interior_pointers(Parrot_Interp interp, size_t size) {
    void*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VI", interp, size);
    event  = CONST_STRING(supervisor, "GC::allocate::allocate_memory_chunk_with_interior_pointers");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        size);
    GC_STUB_CALL_PRE;
    ret = (gc_orig->allocate_memory_chunk_with_interior_pointers(interp, size));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void*  stub_reallocate_memory_chunk_with_interior_pointers(Parrot_Interp interp, void* data,
                                                           size_t oldsize, size_t newsize) {
    void*  ret; PMC *ret_pack;
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VVII", interp, data, oldsize, newsize);
    event  = CONST_STRING(supervisor,
                          "GC::reallocate::reallocate_memory_chunk_with_interior_pointers");
    VTABLE_set_integer_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "size"),
        newsize);
    GC_STUB_CALL_PRE;
    ret = (gc_orig->reallocate_memory_chunk_with_interior_pointers(interp, data, oldsize, newsize));
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, event_data, CONST_STRING(supervisor, "return"), ret_pack);
    GC_STUB_CALL_POST;
    return ret;
}

void  stub_free_memory_chunk(Parrot_Interp interp, void* data) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "VV", interp, data);
    event  = CONST_STRING(supervisor, "GC::free::free_memory_chunk");
    GC_STUB_CALL_PRE;
    (gc_orig->free_memory_chunk(interp, data));
    GC_STUB_CALL_POST;
}

void  stub_block_mark(Parrot_Interp interp) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "V", interp);
    event  = CONST_STRING(supervisor, "GC::administration::block_mark");
    GC_STUB_CALL_PRE;
    (gc_orig->block_mark(interp));
    GC_STUB_CALL_POST;
}

void  stub_unblock_mark(Parrot_Interp interp) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "V", interp);
    event  = CONST_STRING(supervisor, "GC::administration::unblock_mark");
    GC_STUB_CALL_PRE;
    (gc_orig->unblock_mark(interp));
    GC_STUB_CALL_POST;
}

void  stub_block_sweep(Parrot_Interp interp) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "V", interp);
    event  = CONST_STRING(supervisor, "GC::administration::block_sweep");
    GC_STUB_CALL_PRE;
    (gc_orig->block_sweep(interp));
    GC_STUB_CALL_POST;
}

void  stub_unblock_sweep(Parrot_Interp interp) {
    GC_STUB_VARS;
    params = instrument_pack_params(supervisor, "V", interp);
    event  = CONST_STRING(supervisor, "GC::administration::unblock_sweep");
    GC_STUB_CALL_PRE;
    (gc_orig->unblock_sweep(interp));
    GC_STUB_CALL_POST;
}

/* END gc stubs */

/* END OF GENERATED CODE */

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
